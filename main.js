/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => JellyfinPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  serverUrl: "",
  apiKey: "",
  userId: "",
  gridColumns: 4,
  outputFolder: "Jellyfin Movies",
  tagsTemplate: "jellyfin, movie",
  keyTitle: "Title",
  keyOriginalTitle: "Original Title",
  keyDirector: "Director",
  keyCast: "Cast",
  keyRating: "Community Rating",
  keyCriticRating: "Critic Rating",
  keyYear: "Year",
  keyPlot: "Overview",
  keyGenre: "Genre",
  keyParentalRating: "Parental Rating",
  keyProductionLocations: "Production Locations",
  downloadPoster: false,
  posterFolderPath: "Assets/Posters",
  includeTags: true,
  includePlot: true,
  includeCast: true,
  includeRating: true,
  includeCriticRating: true,
  includeOriginalTitle: true,
  includeGenre: true,
  includeProductionLocations: true,
  includeYear: true,
  includeTmdbId: true,
  includePoster: true,
  includeWatched: true,
  keyWatched: "Watched",
  frontmatterOrder: [
    "title",
    "original_title",
    "genre",
    "director",
    "cast",
    "production_locations",
    "rating_community",
    "rating_critic",
    "rating_parental",
    "tags",
    "plot",
    "year",
    "tmdb_id",
    "watched",
    "poster"
  ],
  customFields: []
};
var JellyfinSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Jellyfin Integration Settings" });
    new import_obsidian.Setting(containerEl).setName("Server URL").setDesc("Base URL of your Jellyfin server (e.g., http://myserver.com:8096)").addText((text) => text.setPlaceholder("http://myserver.com:8096").setValue(this.plugin.settings.serverUrl).onChange(async (value) => {
      this.plugin.settings.serverUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("Your Jellyfin API Key").addText((text) => text.setPlaceholder("API Key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
      this.plugin.settings.apiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("User ID").setDesc("Your Jellyfin User ID (optional, required for specific user data)").addText((text) => text.setPlaceholder("User ID").setValue(this.plugin.settings.userId).onChange(async (value) => {
      this.plugin.settings.userId = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Test Connection").setDesc("Verify that your Server URL and API Key are correct.").addButton((button) => button.setButtonText("Test Connection").setCta().onClick(async () => {
      const status = await this.plugin.api.testConnection();
      if (status) {
        new import_obsidian.Notice("\u2705 Connection Successful!");
      } else {
        new import_obsidian.Notice("\u274C Connection Failed. Check settings and console for details.");
      }
    }));
    containerEl.createEl("h3", { text: "UI Settings" });
    new import_obsidian.Setting(containerEl).setName("Grid Columns").setDesc("Number of columns in the library browser (3-6).").addSlider((slider) => slider.setLimits(3, 6, 1).setValue(this.plugin.settings.gridColumns).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.gridColumns = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Note Generation" });
    new import_obsidian.Setting(containerEl).setName("Output Folder").setDesc("Folder where movie notes will be created.").addText((text) => text.setPlaceholder("Jellyfin Movies").setValue(this.plugin.settings.outputFolder).onChange(async (value) => {
      this.plugin.settings.outputFolder = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Tags Template").setDesc("Comma separated tags. Use {{director}}, {{year}}, {{genre}} as placeholders.").addText((text) => text.setPlaceholder("jellyfin, movie, {{director}}").setValue(this.plugin.settings.tagsTemplate).onChange(async (value) => {
      this.plugin.settings.tagsTemplate = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h4", { text: "Frontmatter Order" });
    containerEl.createEl("div", { text: "Drag and drop items to reorder the Frontmatter fields.", cls: "setting-item-description" });
    containerEl.createEl("h4", { text: "Frontmatter Keys & Order" });
    containerEl.createEl("div", { text: "Drag items to reorder. User toggles to include/exclude.", cls: "setting-item-description" });
    new import_obsidian.Setting(containerEl).setName("Add Custom Field").setDesc('Add a new frontmatter key (e.g. "My Rating"). It will be added with an empty value.').addText((text) => text.setPlaceholder("Field Name").onChange((value) => {
      text.inputEl.dataset.value = value;
    })).addButton((btn) => btn.setButtonText("Add").onClick(async () => {
      const inputEl = containerEl.querySelector('input[placeholder="Field Name"]');
      const value = inputEl == null ? void 0 : inputEl.value.trim();
      if (value && !this.plugin.settings.customFields.includes(value) && !this.plugin.settings.frontmatterOrder.includes(value)) {
        this.plugin.settings.customFields.push(value);
        this.plugin.settings.frontmatterOrder.push(value);
        await this.plugin.saveSettings();
        inputEl.value = "";
        this.display();
      } else {
        new import_obsidian.Notice("Invalid or duplicate field name.");
      }
    }));
    const fmContainer = containerEl.createDiv();
    this.renderFrontmatterSettings(fmContainer);
    containerEl.createEl("h4", { text: "Poster Management" });
    new import_obsidian.Setting(containerEl).setName("Download Poster").setDesc("Download the primary image locally to your vault.").addToggle((toggle) => toggle.setValue(this.plugin.settings.downloadPoster).onChange(async (value) => {
      this.plugin.settings.downloadPoster = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.downloadPoster) {
      new import_obsidian.Setting(containerEl).setName("Poster Storage Path").setDesc("Folder where posters will be saved (e.g., Assets/Posters).").addText((text) => text.setPlaceholder("Assets/Posters").setValue(this.plugin.settings.posterFolderPath).onChange(async (value) => {
        this.plugin.settings.posterFolderPath = value;
        await this.plugin.saveSettings();
      }));
    }
  }
  renderFrontmatterSettings(container) {
    container.empty();
    let dragStartIndex = null;
    this.plugin.settings.frontmatterOrder.forEach((key, index) => {
      let setting = null;
      switch (key) {
        case "title":
          setting = new import_obsidian.Setting(container).setName("Title").setDesc("Mandatory").addText((t) => t.setValue(this.plugin.settings.keyTitle).onChange(async (v) => {
            this.plugin.settings.keyTitle = v;
            await this.plugin.saveSettings();
          }));
          break;
        case "director":
          setting = new import_obsidian.Setting(container).setName("Director").setDesc("Mandatory").addText((t) => t.setValue(this.plugin.settings.keyDirector).onChange(async (v) => {
            this.plugin.settings.keyDirector = v;
            await this.plugin.saveSettings();
          }));
          break;
        case "original_title":
          setting = new import_obsidian.Setting(container).setName("Original Title").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeOriginalTitle).onChange(async (v) => {
            this.plugin.settings.includeOriginalTitle = v;
            await this.plugin.saveSettings();
          })).addText((t) => t.setValue(this.plugin.settings.keyOriginalTitle).onChange(async (v) => {
            this.plugin.settings.keyOriginalTitle = v;
            await this.plugin.saveSettings();
          }));
          break;
        case "cast":
          setting = new import_obsidian.Setting(container).setName("Cast").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeCast).onChange(async (v) => {
            this.plugin.settings.includeCast = v;
            await this.plugin.saveSettings();
          })).addText((t) => t.setValue(this.plugin.settings.keyCast).onChange(async (v) => {
            this.plugin.settings.keyCast = v;
            await this.plugin.saveSettings();
          }));
          break;
        case "genre":
          setting = new import_obsidian.Setting(container).setName("Genre").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeGenre).onChange(async (v) => {
            this.plugin.settings.includeGenre = v;
            await this.plugin.saveSettings();
          })).addText((t) => t.setValue(this.plugin.settings.keyGenre).onChange(async (v) => {
            this.plugin.settings.keyGenre = v;
            await this.plugin.saveSettings();
          }));
          break;
        case "year":
          setting = new import_obsidian.Setting(container).setName("Year").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeYear).onChange(async (v) => {
            this.plugin.settings.includeYear = v;
            await this.plugin.saveSettings();
          })).addText((t) => t.setValue(this.plugin.settings.keyYear).onChange(async (v) => {
            this.plugin.settings.keyYear = v;
            await this.plugin.saveSettings();
          }));
          break;
        case "plot":
          setting = new import_obsidian.Setting(container).setName("Plot / Overview").addToggle((toggle) => toggle.setValue(this.plugin.settings.includePlot).onChange(async (v) => {
            this.plugin.settings.includePlot = v;
            await this.plugin.saveSettings();
          })).addText((t) => t.setValue(this.plugin.settings.keyPlot).onChange(async (v) => {
            this.plugin.settings.keyPlot = v;
            await this.plugin.saveSettings();
          }));
          break;
        case "production_locations":
          setting = new import_obsidian.Setting(container).setName("Production Locations").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeProductionLocations).onChange(async (v) => {
            this.plugin.settings.includeProductionLocations = v;
            await this.plugin.saveSettings();
          })).addText((t) => t.setValue(this.plugin.settings.keyProductionLocations).onChange(async (v) => {
            this.plugin.settings.keyProductionLocations = v;
            await this.plugin.saveSettings();
          }));
          break;
        case "rating_community":
          setting = new import_obsidian.Setting(container).setName("Community Rating").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeRating).onChange(async (v) => {
            this.plugin.settings.includeRating = v;
            await this.plugin.saveSettings();
          })).addText((t) => t.setValue(this.plugin.settings.keyRating).onChange(async (v) => {
            this.plugin.settings.keyRating = v;
            await this.plugin.saveSettings();
          }));
          break;
        case "rating_critic":
          setting = new import_obsidian.Setting(container).setName("Critic Rating").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeCriticRating).onChange(async (v) => {
            this.plugin.settings.includeCriticRating = v;
            await this.plugin.saveSettings();
          })).addText((t) => t.setValue(this.plugin.settings.keyCriticRating).onChange(async (v) => {
            this.plugin.settings.keyCriticRating = v;
            await this.plugin.saveSettings();
          }));
          break;
        case "rating_parental":
          setting = new import_obsidian.Setting(container).setName("Parental Rating").setDesc("Renames the parental rating field.").addText((t) => t.setValue(this.plugin.settings.keyParentalRating).onChange(async (v) => {
            this.plugin.settings.keyParentalRating = v;
            await this.plugin.saveSettings();
          }));
          break;
        case "tags":
          setting = new import_obsidian.Setting(container).setName("Tags").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeTags).onChange(async (v) => {
            this.plugin.settings.includeTags = v;
            await this.plugin.saveSettings();
          }));
          break;
        case "tmdb_id":
          setting = new import_obsidian.Setting(container).setName("TmdbId").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeTmdbId).onChange(async (v) => {
            this.plugin.settings.includeTmdbId = v;
            await this.plugin.saveSettings();
          }));
          break;
        case "poster":
          setting = new import_obsidian.Setting(container).setName("Poster Key").setDesc('Include "Poster" field in frontmatter.').addToggle((toggle) => toggle.setValue(this.plugin.settings.includePoster).onChange(async (v) => {
            this.plugin.settings.includePoster = v;
            await this.plugin.saveSettings();
          }));
          break;
        case "watched":
          setting = new import_obsidian.Setting(container).setName("Watched Status").setDesc("Add a checkbox property to track if watched.").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeWatched).onChange(async (v) => {
            this.plugin.settings.includeWatched = v;
            await this.plugin.saveSettings();
          })).addText((t) => t.setValue(this.plugin.settings.keyWatched).onChange(async (v) => {
            this.plugin.settings.keyWatched = v;
            await this.plugin.saveSettings();
          }));
          break;
        default:
          if (this.plugin.settings.customFields.includes(key)) {
            setting = new import_obsidian.Setting(container).setName(key).setDesc("Custom Field").addButton((btn) => btn.setIcon("trash").setTooltip("Delete Field").onClick(async () => {
              this.plugin.settings.customFields = this.plugin.settings.customFields.filter((f) => f !== key);
              this.plugin.settings.frontmatterOrder = this.plugin.settings.frontmatterOrder.filter((f) => f !== key);
              await this.plugin.saveSettings();
              this.renderFrontmatterSettings(container);
            }));
          }
          break;
      }
      if (setting) {
        const item = setting.settingEl;
        item.setAttribute("draggable", "true");
        item.style.cursor = "grab";
        const nameEl = item.querySelector(".setting-item-name");
        if (nameEl) {
          nameEl.prepend(createSpan({ text: "\u2630 ", cls: "jellyfin-drag-handle" }));
        }
        item.ondragstart = (e) => {
          dragStartIndex = index;
          if (e.dataTransfer) {
            e.dataTransfer.effectAllowed = "move";
            e.dataTransfer.setData("text/plain", index.toString());
            item.style.opacity = "0.5";
          }
        };
        item.ondragover = (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";
          item.style.boxShadow = "0 -2px 0 var(--interactive-accent)";
        };
        item.ondragleave = (e) => {
          item.style.boxShadow = "";
        };
        item.ondrop = async (e) => {
          e.preventDefault();
          item.style.boxShadow = "";
          const dragEndIndex = index;
          if (dragStartIndex !== null && dragStartIndex !== dragEndIndex) {
            const items = [...this.plugin.settings.frontmatterOrder];
            const [draggedItem] = items.splice(dragStartIndex, 1);
            items.splice(dragEndIndex, 0, draggedItem);
            this.plugin.settings.frontmatterOrder = items;
            await this.plugin.saveSettings();
            this.renderFrontmatterSettings(container);
          }
        };
        item.ondragend = () => {
          item.style.opacity = "1";
          item.style.boxShadow = "";
        };
      }
    });
  }
};

// src/jellyfin.ts
var import_obsidian2 = require("obsidian");
var JellyfinAPI = class {
  constructor(settings) {
    this.settings = settings;
  }
  getHeaders() {
    return {
      "X-Emby-Token": this.settings.apiKey,
      "Content-Type": "application/json"
    };
  }
  async testConnection() {
    if (!this.settings.serverUrl || !this.settings.apiKey)
      return false;
    try {
      const url = `${this.settings.serverUrl}/System/Info`;
      const response = await (0, import_obsidian2.requestUrl)({
        url,
        method: "GET",
        headers: this.getHeaders()
      });
      return response.status === 200;
    } catch (error) {
      console.error("Jellyfin Connection Failed:", error);
      if (error.status === 401)
        throw new Error("401 Unauthorized: Check API Key / User ID");
      if (error.status === 404)
        throw new Error("404 Not Found: Check Server URL");
      throw error;
    }
  }
  getImageUrl(itemId, type = "Primary") {
    return `${this.settings.serverUrl}/Items/${itemId}/Images/${type}`;
  }
  async getLink(itemId) {
    return `${this.settings.serverUrl}/web/index.html#!/details?id=${itemId}`;
  }
  async getDirectorsOrMovies(parentId) {
    if (!this.settings.serverUrl)
      throw new Error("Server URL is missing.");
    if (!this.settings.userId)
      throw new Error("User ID is missing. Please set it in settings.");
    let url = `${this.settings.serverUrl}/Users/${this.settings.userId}/Items?Recursive=true&IncludeItemTypes=Movie,BoxSet&Fields=ImageTags,PrimaryImageAspectRatio,ProductionYear`;
    if (parentId) {
      url += `&ParentId=${parentId}`;
    }
    if (!parentId) {
      const viewsUrl = `${this.settings.serverUrl}/Users/${this.settings.userId}/Views`;
      const viewsResponse = await (0, import_obsidian2.requestUrl)({
        url: viewsUrl,
        method: "GET",
        headers: this.getHeaders()
      });
      return viewsResponse.json.Items;
    }
    try {
      const response = await (0, import_obsidian2.requestUrl)({
        url,
        method: "GET",
        headers: this.getHeaders()
      });
      return response.json.Items;
    } catch (e) {
      console.error(`[Jellyfin Plugin] API Error ${e.status} fetching ${url}`, e);
      new import_obsidian2.Notice(`Jellyfin API Error: ${e.status}. Check Console.`);
      throw e;
    }
  }
  // Fetch generic items by parent ID (Folder browsing)
  async getItemsByParent(parentId) {
    const url = `${this.settings.serverUrl}/Users/${this.settings.userId}/Items?ParentId=${parentId}&Fields=ImageTags,PrimaryImageAspectRatio,ProductionYear`;
    const response = await (0, import_obsidian2.requestUrl)({
      url,
      method: "GET",
      headers: this.getHeaders()
    });
    return response.json.Items;
  }
  // New: Fetch FULL details for a specific item (Import usage)
  async getItemDetails(itemId) {
    const url = `${this.settings.serverUrl}/Users/${this.settings.userId}/Items/${itemId}?Fields=People,Genres,ProductionLocations,CommunityRating,CriticRating,Overview,PremiereDate,OfficialRating,ProviderIds,Tags,ImageTags`;
    const response = await (0, import_obsidian2.requestUrl)({
      url,
      method: "GET",
      headers: this.getHeaders()
    });
    return response.json;
  }
};

// src/modals.ts
var import_obsidian3 = require("obsidian");
var MovieSuggestModal = class extends import_obsidian3.SuggestModal {
  constructor(app, plugin, items, onChoose) {
    super(app);
    this.plugin = plugin;
    this.items = items;
    this.onChoose = onChoose;
  }
  getSuggestions(query) {
    return this.items.filter(
      (item) => item.Name.toLowerCase().includes(query.toLowerCase())
    );
  }
  renderSuggestion(item, el) {
    el.createEl("div", { text: item.Name });
    el.createEl("small", { text: item.ProductionYear ? String(item.ProductionYear) : "" });
  }
  onChooseSuggestion(item, _evt) {
    this.onChoose(item);
  }
};
var DirectorFolderSuggestModal = class extends import_obsidian3.SuggestModal {
  constructor(app, plugin, items, onChoose) {
    super(app);
    this.plugin = plugin;
    this.items = items;
    this.onChoose = onChoose;
  }
  getSuggestions(query) {
    return this.items.filter(
      (item) => item.Name.toLowerCase().includes(query.toLowerCase())
    );
  }
  renderSuggestion(item, el) {
    el.createEl("div", { text: item.Name });
    el.createEl("small", { text: item.Type });
  }
  onChooseSuggestion(item, _evt) {
    this.onChoose(item);
  }
};

// src/browser.ts
var import_obsidian4 = require("obsidian");
var JellyfinBrowserModal = class extends import_obsidian4.Modal {
  constructor(app, plugin) {
    super(app);
    this.currentParentId = null;
    this.currentItems = [];
    this.selectedItems = /* @__PURE__ */ new Set();
    // IDs of selected items
    this.breadcrumbs = [];
    this.isSelectAll = false;
    this.plugin = plugin;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("jellyfin-browser-container");
    await this.loadItems();
    this.render();
  }
  async loadItems(parentId = null) {
    try {
      if (parentId) {
        this.currentItems = await this.plugin.api.getItemsByParent(parentId);
      } else {
        this.currentItems = await this.plugin.api.getDirectorsOrMovies();
      }
      this.currentParentId = parentId;
      this.selectedItems.clear();
      this.isSelectAll = false;
    } catch (error) {
      new import_obsidian4.Notice("Error loading items: " + error.message);
    }
  }
  addToBreadcrumb(id, name) {
    if (this.breadcrumbs.length > 0) {
      const last = this.breadcrumbs[this.breadcrumbs.length - 1];
      if (last.id === id)
        return;
    }
    this.breadcrumbs.push({ id, name });
  }
  popBreadcrumbTo(index) {
    this.breadcrumbs = this.breadcrumbs.slice(0, index + 1);
    const target = this.breadcrumbs[index];
    this.loadItems(target.id).then(() => this.render());
  }
  goBack() {
    if (this.breadcrumbs.length > 0) {
      const newLength = this.breadcrumbs.length - 1;
      if (newLength === 0) {
        this.breadcrumbs = [];
        this.loadItems(null).then(() => this.render());
      } else {
        this.popBreadcrumbTo(newLength - 1);
      }
    }
  }
  render() {
    const { contentEl } = this;
    contentEl.empty();
    const header = contentEl.createDiv("jellyfin-browser-header");
    const backBtn = header.createEl("button", { cls: "clickable-icon", title: "Go Back" });
    (0, import_obsidian4.setIcon)(backBtn, "arrow-left");
    backBtn.onclick = () => this.goBack();
    if (this.breadcrumbs.length === 0)
      backBtn.disabled = true;
    const homeBtn = header.createEl("button", { cls: "clickable-icon", title: "Go Home" });
    (0, import_obsidian4.setIcon)(homeBtn, "home");
    homeBtn.onclick = async () => {
      this.breadcrumbs = [];
      await this.loadItems(null);
      this.render();
    };
    const breadcrumbsContainer = header.createDiv("jellyfin-breadcrumbs");
    this.breadcrumbs.forEach((crumb, index) => {
      if (index > 0)
        breadcrumbsContainer.createSpan({ text: " > " });
      const crumbEl = breadcrumbsContainer.createSpan({
        text: crumb.name,
        cls: "breadcrumb-item"
      });
      crumbEl.style.cursor = "pointer";
      crumbEl.onclick = () => this.popBreadcrumbTo(index);
    });
    const toolbar = contentEl.createDiv("jellyfin-browser-toolbar");
    toolbar.style.padding = "5px 10px";
    toolbar.style.display = "flex";
    toolbar.style.gap = "10px";
    toolbar.style.alignItems = "center";
    toolbar.style.background = "var(--background-secondary)";
    const selectAllContainer = toolbar.createDiv({ cls: "jellyfin-select-all" });
    selectAllContainer.style.display = "flex";
    selectAllContainer.style.alignItems = "center";
    selectAllContainer.style.gap = "5px";
    const selectAllCb = selectAllContainer.createEl("input", { type: "checkbox" });
    selectAllCb.checked = this.isSelectAll;
    selectAllCb.onclick = (_e) => {
      this.isSelectAll = selectAllCb.checked;
      if (this.isSelectAll) {
        this.currentItems.forEach((i) => this.selectedItems.add(i.Id));
      } else {
        this.selectedItems.clear();
      }
      this.updateSelectionCount();
      this.render();
    };
    selectAllContainer.createSpan({ text: "Select All" });
    this.selectionCountEl = toolbar.createSpan({ cls: "jellyfin-selection-count" });
    this.selectionCountEl.style.marginLeft = "10px";
    this.selectionCountEl.style.fontSize = "0.9em";
    this.selectionCountEl.style.color = "var(--text-muted)";
    this.updateSelectionCount();
    const searchContainer = toolbar.createDiv({ cls: "jellyfin-search-container" });
    searchContainer.style.flexGrow = "1";
    searchContainer.style.maxWidth = "300px";
    searchContainer.style.marginLeft = "10px";
    const searchInput = searchContainer.createEl("input", { type: "text", placeholder: "Search..." });
    searchInput.style.width = "100%";
    searchInput.oninput = (e) => {
      const query = e.target.value.toLowerCase();
      this.filterItems(query);
    };
    const buttonsContainer = toolbar.createDiv();
    buttonsContainer.style.marginLeft = "auto";
    buttonsContainer.style.display = "flex";
    buttonsContainer.style.gap = "10px";
    const createTableBtn = buttonsContainer.createEl("button", { text: "Create Table" });
    createTableBtn.onclick = async () => {
      const itemsToProcess = this.currentItems.filter((i) => this.selectedItems.has(i.Id));
      if (itemsToProcess.length === 0) {
        new import_obsidian4.Notice("Please select items first.");
        return;
      }
      await this.plugin.generateTableFromItems(itemsToProcess);
      this.close();
    };
    const createNotesBtn = toolbar.createEl("button", { text: "Import Notes" });
    createNotesBtn.onclick = async () => {
      const itemsToProcess = this.currentItems.filter((i) => this.selectedItems.has(i.Id));
      if (itemsToProcess.length === 0) {
        new import_obsidian4.Notice("Please select items first.");
        return;
      }
      await this.plugin.createNotesForItems(itemsToProcess);
      this.close();
    };
    const grid = contentEl.createDiv("jellyfin-browser-grid");
    this.gridEl = grid;
    grid.style.setProperty("--grid-columns", this.plugin.settings.gridColumns.toString());
    this.renderGridItems(this.currentItems);
  }
  updateSelectionCount() {
    if (this.selectionCountEl) {
      const count = this.selectedItems.size;
      this.selectionCountEl.setText(count > 0 ? `${count} selected` : "");
    }
  }
  // Separated Grid Rendering for Filtering
  renderGridItems(items) {
    if (!this.gridEl)
      return;
    this.gridEl.empty();
    if (items.length === 0) {
      this.gridEl.createDiv({ text: "No items found." });
      return;
    }
    items.forEach((item) => {
      const card = this.gridEl.createDiv("jellyfin-card");
      if (this.selectedItems.has(item.Id)) {
        card.classList.add("is-selected");
        card.style.borderColor = "var(--interactive-accent)";
        card.style.borderWidth = "2px";
        card.style.borderStyle = "solid";
      }
      const isFolder = item.Type === "Collection" || item.Type === "UserView" || item.IsFolder;
      const hasImage = item.ImageTags && item.ImageTags.Primary;
      card.onclick = (e) => {
        if (isFolder) {
          this.addToBreadcrumb(item.Id, item.Name);
          this.loadItems(item.Id).then(() => this.render());
        } else {
        }
      };
      const cbContainer = card.createDiv("jellyfin-card-checkbox");
      const cb = cbContainer.createEl("input", { type: "checkbox", cls: "jellyfin-specific-checkbox" });
      cb.checked = this.selectedItems.has(item.Id);
      cb.onclick = (e) => {
        e.stopPropagation();
        if (cb.checked) {
          this.selectedItems.add(item.Id);
        } else {
          this.selectedItems.delete(item.Id);
        }
        this.updateSelectionCount();
        if (cb.checked) {
          card.classList.add("is-selected");
          card.style.borderColor = "var(--interactive-accent)";
          card.style.borderWidth = "2px";
          card.style.borderStyle = "solid";
          card.style.backgroundColor = "var(--background-secondary-alt)";
        } else {
          card.classList.remove("is-selected");
          card.style.removeProperty("border-color");
          card.style.removeProperty("border-width");
          card.style.removeProperty("border-style");
          card.style.removeProperty("background-color");
        }
      };
      const contentContainer = card.createDiv("jellyfin-card-content");
      if (hasImage) {
        const imgUrl = this.plugin.api.getImageUrl(item.Id);
        const img = contentContainer.createEl("img", { cls: "jellyfin-poster" });
        img.src = imgUrl;
      } else {
        const iconDiv = contentContainer.createDiv("jellyfin-folder-icon");
        (0, import_obsidian4.setIcon)(iconDiv, isFolder ? "folder" : "film");
      }
      contentContainer.createDiv({ cls: "jellyfin-card-title", text: item.Name });
    });
  }
  filterItems(query) {
    if (!query) {
      this.renderGridItems(this.currentItems);
      return;
    }
    const filtered = this.currentItems.filter((item) => item.Name.toLowerCase().includes(query));
    this.renderGridItems(filtered);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var JellyfinPlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.api = new JellyfinAPI(this.settings);
    this.addSettingTab(new JellyfinSettingTab(this.app, this));
    (0, import_obsidian5.addIcon)("jellyfin", '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><title>Jellyfin</title><path d="M12 0C8.8 0-1.4 18.5.2 21.7s22.1 3 23.6 0C25.4 18.6 15.2 0 12 0m7.8 19c-1 2-14.5 2-15.6 0C3.2 16.9 10 4.8 12 4.8s8.8 12.1 7.8 14.2M12 9.2c-1 0-4.4 6.1-4 7.2.6 1 7.4 1 8 0 .4-1-3-7.2-4-7.2"/></svg>');
    this.addRibbonIcon("jellyfin", "Browse Jellyfin Library", () => {
      new JellyfinBrowserModal(this.app, this).open();
    });
    this.addCommand({
      id: "jellyfin-browse-library",
      name: "Browse Library (Rich UI)",
      callback: () => {
        new JellyfinBrowserModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "jellyfin-test-connection",
      name: "Test Jellyfin Connection",
      callback: async () => {
        const result = await this.api.testConnection();
        new import_obsidian5.Notice(result ? "Connection Successful!" : "Connection Failed. Check Settings.");
      }
    });
    this.addCommand({
      id: "jellyfin-generate-table",
      name: "Generate Movies Table (Director Structure)",
      callback: async () => {
        await this.generateDirectorMoviesTable();
      }
    });
    this.addCommand({
      id: "jellyfin-import-movie-note",
      name: "Import Movie to Note",
      callback: async () => {
        await this.importMovieToNote();
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.api = new JellyfinAPI(this.settings);
  }
  // Logic for Table Generation
  async generateDirectorMoviesTable() {
    try {
      new import_obsidian5.Notice("Fetching library...");
      const views = await this.api.getDirectorsOrMovies();
      new DirectorFolderSuggestModal(this.app, this, views, async (selectedView) => {
        new import_obsidian5.Notice(`Fetching directors from ${selectedView.Name}...`);
        const directors = await this.api.getItemsByParent(selectedView.Id);
        let tableMarkdown = "| **Director** | **Item 1** | **Item 2** | **Item 3** | **Item 4** |\n|---|---|---|---|---|\n";
        const directorsToProcess = directors.slice(0, 5);
        for (const director of directorsToProcess) {
          const movies = await this.api.getItemsByParent(director.Id);
          const movieNames = movies.map((m) => m.Name).slice(0, 4);
          while (movieNames.length < 4)
            movieNames.push("");
          tableMarkdown += `| **${director.Name}** | ${movieNames.join(" | ")} |
`;
        }
        const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
        if (view) {
          const cursor = view.editor.getCursor();
          view.editor.replaceRange(tableMarkdown, cursor);
        } else {
          new import_obsidian5.Notice("Open a Markdown file to insert the table.");
        }
      }).open();
    } catch (e) {
      new import_obsidian5.Notice("Error fetching data: " + e.message);
      console.error(e);
    }
  }
  // New helper for Button in Browser Modal
  async generateTableForFolder(parentId, folderName) {
    try {
      const children = await this.api.getItemsByParent(parentId);
      const movies = children.filter((c) => c.Type === "Movie");
      const folders = children.filter((c) => c.IsFolder || c.Type === "Collection");
      let tableMarkdown = "";
      if (folders.length > 0) {
        tableMarkdown = `| **${folderName}** | **Item 1** | **Item 2** | **Item 3** | **Item 4** |
|---|---|---|---|---|
`;
        let count = 0;
        const total = folders.length;
        new import_obsidian5.Notice(`Generating table for ${total} items. This may take a moment...`);
        for (const folder of folders) {
          count++;
          if (count % 5 === 0)
            new import_obsidian5.Notice(`Processing ${count}/${total}...`);
          const subItems = await this.api.getItemsByParent(folder.Id);
          const names = subItems.map((m) => m.Name).slice(0, 4);
          while (names.length < 4)
            names.push("");
          tableMarkdown += `| **${folder.Name}** | ${names.join(" | ")} |
`;
        }
      } else if (movies.length > 0) {
        new import_obsidian5.Notice("This folder contains movies directly. Please go up one level to generate a Director table.");
        return;
      } else {
        new import_obsidian5.Notice("No items found to generate table.");
        return;
      }
      const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
      if (view) {
        const cursor = view.editor.getCursor();
        view.editor.replaceRange(tableMarkdown, cursor);
        new import_obsidian5.Notice("Table generated!");
      } else {
        new import_obsidian5.Notice("Open a Markdown file to insert the table.");
      }
    } catch (e) {
      new import_obsidian5.Notice("Error generating table: " + e.message);
    }
  }
  // Logic for Note Import
  async importMovieToNote() {
    try {
      const views = await this.api.getDirectorsOrMovies();
      new DirectorFolderSuggestModal(this.app, this, views, async (selectedView) => {
        new import_obsidian5.Notice(`Fetching contents of ${selectedView.Name}...`);
        const directors = await this.api.getItemsByParent(selectedView.Id);
        new DirectorFolderSuggestModal(this.app, this, directors, async (selectedDirector) => {
          const movies = await this.api.getItemsByParent(selectedDirector.Id);
          new MovieSuggestModal(this.app, this, movies, async (movie) => {
            await this.createMovieNote(movie);
          }).open();
        }).open();
      }).open();
    } catch (e) {
      new import_obsidian5.Notice("Error: " + e.message);
    }
  }
  async createMovieNote(basicMovie) {
    var _a;
    new import_obsidian5.Notice(`Fetching details for ${basicMovie.Name}...`);
    const movie = await this.api.getItemDetails(basicMovie.Id);
    let folderPath = this.settings.outputFolder.trim().replace(/\/$/, "");
    if (folderPath && folderPath !== "") {
      if (!this.app.vault.getAbstractFileByPath(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      folderPath = folderPath + "/";
    } else {
      folderPath = "";
    }
    const filename = `${folderPath}${movie.Name.replace(/[\\/:*?"<>|]/g, "")}.md`;
    const cleanTitle = movie.Name.replace(/:/g, " \u2014");
    const cleanOverview = (movie.Overview || "").replace(/"/g, "'");
    let tagsList = [];
    const templateParts = this.settings.tagsTemplate.split(",").map((s) => s.trim()).filter((s) => s.length > 0);
    const directorName = movie.People ? ((_a = movie.People.find((p) => p.Type === "Director")) == null ? void 0 : _a.Name) || "" : "";
    const year = movie.ProductionYear || "";
    const genres = movie.Genres ? movie.Genres : [];
    const actors = movie.People ? movie.People.filter((p) => p.Type === "Actor").map((p) => p.Name) : [];
    for (const part of templateParts) {
      if (part === "{{director}}") {
        if (directorName)
          tagsList.push(this.slugify(directorName));
      } else if (part === "{{title}}") {
        tagsList.push(this.slugify(movie.Name));
      } else if (part === "{{year}}") {
        if (year)
          tagsList.push(this.slugify(year.toString()));
      } else if (part === "{{genre}}") {
        genres.forEach((g) => tagsList.push(this.slugify(g)));
      } else if (part === "{{actors}}") {
        actors.forEach((a) => tagsList.push(this.slugify(a)));
      } else {
        tagsList.push(this.slugify(part));
      }
    }
    tagsList = [...new Set(tagsList)];
    const fmLines = [`---`];
    const generators = {
      "title": () => {
        fmLines.push(`${this.settings.keyTitle}: ${cleanTitle}`);
      },
      "original_title": () => {
        if (this.settings.includeOriginalTitle)
          fmLines.push(`${this.settings.keyOriginalTitle}: ${movie.OriginalTitle || ""}`);
      },
      "genre": () => {
        if (this.settings.includeGenre)
          fmLines.push(`${this.settings.keyGenre}: ${genres.join(", ")}`);
      },
      "director": () => {
        if (this.settings.includeCast)
          fmLines.push(`${this.settings.keyDirector}: ${this.getPeopleByType(movie.People, "Director")}`);
      },
      "cast": () => {
        if (this.settings.includeCast)
          fmLines.push(`${this.settings.keyCast}: ${this.getPeopleByType(movie.People, "Actor")}`);
      },
      "production_locations": () => {
        if (this.settings.includeProductionLocations)
          fmLines.push(`${this.settings.keyProductionLocations}: ${movie.ProductionLocations ? movie.ProductionLocations.join(", ") : ""}`);
      },
      "rating_community": () => {
        if (this.settings.includeRating) {
          const rawRating = movie.CommunityRating;
          const commRating = parseFloat(rawRating);
          if (!isNaN(commRating) && isFinite(commRating)) {
            fmLines.push(`${this.settings.keyRating}: ${commRating}`);
          }
        }
      },
      "rating_critic": () => {
        if (this.settings.includeCriticRating) {
          const criticRating = parseFloat(movie.CriticRating);
          if (typeof criticRating === "number" && !isNaN(criticRating)) {
            fmLines.push(`${this.settings.keyCriticRating}: ${criticRating}`);
          } else if (movie.CriticRating) {
            const cleanCritic = parseFloat(movie.CriticRating.replace("%", ""));
            if (!isNaN(cleanCritic)) {
              fmLines.push(`${this.settings.keyCriticRating}: ${cleanCritic}`);
            }
          }
        }
      },
      "rating_parental": () => {
        if (movie.OfficialRating) {
          fmLines.push(`${this.settings.keyParentalRating}: ${movie.OfficialRating}`);
        }
      },
      "tags": () => {
        if (this.settings.includeTags && tagsList.length > 0) {
          const tagsString = tagsList.join(", ");
          fmLines.push(`tags: [${tagsString}]`);
        }
      },
      "plot": () => {
        if (this.settings.includePlot)
          fmLines.push(`${this.settings.keyPlot}: "${cleanOverview}"`);
      },
      "year": () => {
        if (this.settings.includeYear) {
          const prodYear = parseInt(movie.ProductionYear);
          if (!isNaN(prodYear)) {
            fmLines.push(`${this.settings.keyYear}: ${prodYear}-01-01`);
          }
        }
      },
      "tmdb_id": () => {
        var _a2;
        if (this.settings.includeTmdbId)
          fmLines.push(`TmdbId: ${((_a2 = movie.ProviderIds) == null ? void 0 : _a2.Tmdb) || ""}`);
      },
      "watched": () => {
        if (this.settings.includeWatched)
          fmLines.push(`${this.settings.keyWatched}: false`);
      },
      "poster": async () => {
        if (this.settings.includePoster) {
          const posterUrl = `${this.settings.serverUrl}/Items/${movie.Id}/Images/Primary`;
          if (this.settings.downloadPoster) {
            const localPosterPath = await this.downloadPosterImage(movie, posterUrl);
            fmLines.push(`Poster: ${localPosterPath || posterUrl}`);
          } else {
            fmLines.push(`Poster: ${posterUrl}`);
          }
        }
      }
    };
    const order = this.settings.frontmatterOrder || DEFAULT_SETTINGS.frontmatterOrder;
    for (const key of order) {
      const generator = generators[key];
      if (generator) {
        await generator();
      } else if (this.settings.customFields && this.settings.customFields.includes(key)) {
        fmLines.push(`${key}: `);
      }
    }
    fmLines.push(`---`);
    const frontmatter = fmLines.join("\n");
    try {
      await this.app.vault.create(filename, frontmatter);
      new import_obsidian5.Notice(`Created note: ${filename}`);
      const file = this.app.vault.getAbstractFileByPath(filename);
      if (file instanceof import_obsidian5.TFile) {
        this.app.workspace.getLeaf(true).openFile(file);
      }
    } catch (e) {
      new import_obsidian5.Notice("Error creating note: " + e.message);
    }
  }
  slugify(text) {
    return text.toString().replace(/\s+/g, "_").replace(/[#,.\[\]:;"]/g, "");
  }
  getPeopleByType(people, type) {
    if (!people)
      return "";
    return people.filter((p) => p.Type === type).map((p) => p.Name).join(", ");
  }
  // --- New Bulk Action Handlers ---
  async generateTableFromItems(items) {
    try {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
      if (!view) {
        new import_obsidian5.Notice("Open a Markdown file to insert the table.");
        return;
      }
      let tableMarkdown = "| **Name** | **Item 1** | **Item 2** | **Item 3** | **Item 4** |\n|---|---|---|---|---|\n";
      let count = 0;
      const total = items.length;
      new import_obsidian5.Notice(`Generating table for ${total} items...`);
      for (const item of items) {
        count++;
        if (count % 5 === 0)
          new import_obsidian5.Notice(`Processing ${count}/${total}...`);
        if (item.IsFolder || item.Type === "Collection" || item.Type === "UserView") {
          const subItems = await this.api.getItemsByParent(item.Id);
          const names = subItems.map((m) => m.Name).slice(0, 4);
          while (names.length < 4)
            names.push("");
          tableMarkdown += `| **${item.Name}** | ${names.join(" | ")} |
`;
        } else {
          tableMarkdown += `| **${item.Name}** | (Movie) | | | |
`;
        }
      }
      const cursor = view.editor.getCursor();
      view.editor.replaceRange(tableMarkdown, cursor);
      new import_obsidian5.Notice("Table generated!");
    } catch (e) {
      new import_obsidian5.Notice("Error: " + e.message);
    }
  }
  async createNotesForItems(items) {
    let created = 0;
    new import_obsidian5.Notice(`Importing ${items.length} notes...`);
    for (const item of items) {
      if (item.Type === "Movie") {
        await this.createMovieNote(item);
        created++;
      } else if (item.IsFolder || item.Type === "Collection") {
        const subItems = await this.api.getItemsByParent(item.Id);
        const subMovies = subItems.filter((i) => i.Type === "Movie");
        for (const m of subMovies) {
          await this.createMovieNote(m);
          created++;
        }
      }
    }
    new import_obsidian5.Notice(`Finished! Created/Updated ${created} notes.`);
  }
  async downloadPosterImage(movie, url) {
    var _a;
    try {
      const folderPath = this.settings.posterFolderPath.replace(/\/$/, "");
      if (!this.app.vault.getAbstractFileByPath(folderPath)) {
        await this.app.vault.createFolder(folderPath);
      }
      const safeName = movie.Name.replace(/[\\/:*?"<>|]/g, "").trim();
      const director = movie.People ? (_a = movie.People.find((p) => p.Type === "Director")) == null ? void 0 : _a.Name : null;
      let filenameBase = safeName;
      if (director) {
        const safeDirector = director.replace(/[\\/:*?"<>|]/g, "").trim();
        filenameBase = `${safeName} \u2014 ${safeDirector}`;
      }
      const filename = `${folderPath}/${filenameBase}.jpg`;
      if (this.app.vault.getAbstractFileByPath(filename)) {
        return filename;
      }
      const response = await (0, import_obsidian5.requestUrl)({ url });
      if (response.status === 200) {
        await this.app.vault.createBinary(filename, response.arrayBuffer);
        return filename;
      }
      return null;
    } catch (e) {
      console.error("Failed to download poster", e);
      new import_obsidian5.Notice(`Failed to download poster for ${movie.Name}`);
      return null;
    }
  }
};
